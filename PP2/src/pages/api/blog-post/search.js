// AI Disclosure: This file may partially contain code generated by models such as GitHub Copilot or ChatGPT
import prisma from "../../../utils/db";

export default async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const {
    title,
    content,
    tag,
    template,
    sortBy = 'rating',
    order = 'desc',
    page = 1,
    limit = 10,
  } = req.query;

  const skip = (parseInt(page, 10) - 1) * parseInt(limit, 10);
  const take = parseInt(limit, 10);

  try {
    // Fetch blog posts based on the search criteria, excluding hidden posts
    const posts = await prisma.blogPost.findMany({
      where: {
        AND: [
          { hidden: false }, // Ensure only non-hidden posts are fetched
          title ? { title: { contains: title, mode: 'insensitive' } } : undefined,
          content ? { content: { contains: content, mode: 'insensitive' } } : undefined,
          tag ? { tags: { some: { name: { contains: tag, mode: 'insensitive' } } } } : undefined,
          template ? { templates: { some: { title: { contains: template, mode: 'insensitive' } } } } : undefined,
        ].filter(Boolean),
      },
      include: {
        tags: { select: { name: true } }, // Include tag names only
        user: { select: { id: true, firstName: true, lastName: true } }, // Include user details
        templates: { select: { id: true, title: true, fileContent: true } }, // Include templates details
        comments: {
          where: { hidden: false }, // Only include non-hidden comments
          include: {
            user: { select: { firstName: true, lastName: true } }, // Limited user info for comments
          },
        },
      },
      orderBy: {
        [sortBy]: order === 'desc' ? 'desc' : 'asc',
      },
      skip,
      take,
    });

    // Sort comments by rating within each post if necessary
    const sortedPosts = posts.map((post) => {
      post.comments = post.comments.sort((a, b) => (order === 'desc' ? b.rating - a.rating : a.rating - b.rating));
      return post;
    });

    // Get total count for pagination metadata, excluding hidden posts
    const totalPosts = await prisma.blogPost.count({
      where: {
        AND: [
          { hidden: false }, // Ensure only non-hidden posts are counted
          title ? { title: { contains: title, mode: 'insensitive' } } : undefined,
          content ? { content: { contains: content, mode: 'insensitive' } } : undefined,
          tag ? { tags: { some: { name: { contains: tag, mode: 'insensitive' } } } } : undefined,
          template ? { templates: { some: { title: { contains: template, mode: 'insensitive' } } } } : undefined,
        ].filter(Boolean),
      },
    });
    const totalPages = Math.ceil(totalPosts / take);

    res.status(200).json({
      posts: sortedPosts,
      pagination: {
        totalItems: totalPosts,
        totalPages,
        currentPage: parseInt(page, 10),
        pageSize: take,
      },
    });
  } catch (error) {
    console.error('Failed to search blog posts:', error);
    res.status(500).json({ error: 'Failed to search blog posts' });
  }
}
