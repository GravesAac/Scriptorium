// AI Disclosure: This file may partially contain code generated by models such as GitHub Copiolot or ChatGPT
import prisma from "../../../utils/db";
import { authMiddleware } from '../../../utils/middleware';

async function handler(req, res) {
    if (req.method === 'GET') {
        const { id } = req.query;

        if (id === undefined) {
            return res.status(400).json({ "error": "Template ID is required" });
        }

        const template = await prisma.template.findMany({
            where: {
                id: parseInt(id)
            }, 
            include: {
                tags: true,
            }
        });

        if (template.length === 0) {
            return res.status(404).json({ "error": "Template not found" });
        } else {
            // console.log(template[0].tags);
            return res.status(200).json(template[0]);
        }

    } else if (req.method === 'PUT') {
        const { id } = req.query;
        const { title, explaination, content, tags } = req.body;
        const { user } = req;
        // maybe add some validation here later
        if ((id) === undefined || isNaN(parseInt(id))) {
            return res.status(400).json({ "error": "Template ID is required" });
        }
        // if (title === undefined || explaination === undefined || content === undefined || tags === undefined) {
        //     return res.status(400).json({ "error": "Title, explaination, content and tags are required" });
        // }

        let originalTemplate;

        try {
            originalTemplate = await prisma.template.findUniqueOrThrow({ 
                where: { id: parseInt(id) },
                include: { tags: true },
            });
            if (originalTemplate.userId !== user.userId) {
                return res.status(403).json({ "error": "Unauthorized to update this template (You are not the owner.)" });
            }
        } catch (error) {
            return res.status(404).json({ "error": "Template id not found" });
        }

        let tagList = [];
        if (tags !== undefined) {
            tagList = tags.split(',');
        }

        // console.log(originalTemplate);

        try {
            if (tags !== undefined) {
                // remove all old tags
                await prisma.template.update({
                    where: {
                        id: parseInt(id)
                    },
                    data: {
                        tags: {
                            disconnect: originalTemplate.tags
                        }
                    }
                });
            }

            await prisma.template.update({
                where: {
                    id: parseInt(id)
                },
                data: {
                    title,
                    explaination,
                    fileContent: content,
                    tags: {
                        connectOrCreate: tagList.map(tag => ({
                        where: { name: tag }, // Check if the tag exists
                        create: { name: tag }, // Create tag if it doesn't exist
                        }))
                    }, 
                    lastEditTime: new Date()
                }
            });
            return res.status(200).json({ "message": "Template updated" });
        } catch (error) {
            console.error(error);
            return res.status(500).json({ "error": "Failed to update template" });
        }

    } else if (req.method === 'DELETE') {
        const { id } = req.query;
        const { user } = req;
        
        if ((id) === undefined || isNaN(parseInt(id))) {
            return res.status(400).json({ "error": "Template ID is required" });
        }

        try {
            const template = await prisma.template.findUniqueOrThrow({ where: { id: parseInt(id) } });
            if (template.userId !== user.userId) {
                return res.status(403).json({ "error": "Unauthorized to delete this template (You are not the owner.)" });
            }
        } catch (error) {
            return res.status(404).json({ "error": "Template id not found" });
        }

        try {
            await prisma.template.delete({
                where: {
                    id: parseInt(id)
                }
            });
            return res.status(200).json({ "message": "Template deleted" });
        } catch (error) {
            console.error(error);
            return res.status(500).json({ "error": "Failed to delete template" });
        }

    } else {
        return res.status(405).json({ "error": "Method not allowed" });
    }
}

function authOnPutAndDeleteOnly(req, res) {
    if (req.method === 'PUT' || req.method === 'DELETE') {
        return authMiddleware(handler)(req, res);
    } else {
        return handler(req, res);
    }
}

export default authOnPutAndDeleteOnly; // Protect the PUT and DELETE requests with authMiddleware