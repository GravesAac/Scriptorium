// AI Disclosure: This file may partially contain code generated by models such as GitHub Copiolot or ChatGPT
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs';
import crypto from 'crypto';

const execAsync = promisify(exec);

// Creating a hash to prevent filename conflicts
const hashName = (codeInput) => {
    const time = Date.now().toString();
    const random = Math.random().toString();
    const hash = crypto.createHash('sha256').update(codeInput + time + random).digest('hex');
    return hash;
}

export async function execute(code, language, stdin) {
    // Code is exceuted in a folder called user_execution, you are free to delete contents 
    // of this folder (NOT the folder itself) after the execution to free up space
    // Testing note: Due to how json is parsed, before inputting user code into the API, 
    // replace all quotes with escaped quotes, \ with \\, and newlines with \n
    let command = "";
    try {
        const hashed = hashName(code);
        switch (language) {
            case "java":
                // Due to the shared execution environment and the nature of the Java compiler, 
                // there are some limitations to how the java execution works, 
                // This will no longer be an issue once we move to docker in phase 2
                const javaClassNameResult = code.match(/public\s+class\s+(\w+)/);
                if (!javaClassNameResult) {
                    throw new Error('Public java class name not found');
                }
                const javaClassName = javaClassNameResult[1];
                await fs.promises.writeFile(`user_execution/${javaClassName}.java`, code);
                await execAsync(`javac user_execution/${javaClassName}.java`);
                command = `echo "${stdin}" | java -cp user_execution ${javaClassName}`;
                break;
            case "javascript":
                await fs.promises.writeFile(`user_execution/script_${hashed}.js`, code);
                command = `echo "${stdin}" | node user_execution/script_${hashed}.js`;
                break;
            case "python":
                await fs.promises.writeFile(`user_execution/script_${hashed}.py`, code);
                command = `echo "${stdin}" | python3 user_execution/script_${hashed}.py`;
                break;
            case "c":
                await fs.promises.writeFile(`user_execution/script_${hashed}.c`, code);
                await execAsync(`gcc user_execution/script_${hashed}.c -o user_execution/script_${hashed}`);
                command = `echo "${stdin}" | ./user_execution/script_${hashed}`;
                break;
            case "cpp":
                await fs.promises.writeFile(`user_execution/script_${hashed}.cpp`, code);
                await execAsync(`g++ user_execution/script_${hashed}.cpp -o user_execution/script_${hashed}`);
                command = `echo "${stdin}" | ./user_execution/script_${hashed}`;
                break;
            default:
                throw new Error('Language not supported :(');
        }
    } catch (error) {
        console.error(error);
        console.error('Failed to compile');
        throw error;
    }

    try {
        const { stdout, stderr } = await execAsync(command);
        if (stderr) {
            throw new Error(stderr);
        }
        return stdout;
    } catch (error) {
        console.error(error);
        console.error('Failed to execute');
        throw error;
    }
}